== Tile format

Tiles are built using the GeoJSON specification.

They're built in two phases, though, because it takes a long time to generate GeoJSON data, even after optimization.

=== Phase 1: GeoJSON data, UTFGrid

See GeoJSON 1.0: http://geojson.org/geojson-spec.html
See UTFGrid 1.2 spec (as of 2012-01-11): https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md

A tile looks like this:

{
  "type": "FeatureCollection", /* GeoJSON */
  "features": [ /* GeoJSON */
    {
      "type": "Feature",
      "geometry": ...GeoJSON geometry...
      "id": "DisseminationArea-12314",
      "properties": {
        "uid": "12314",
        "type": "DisseminationArea",
        "name": "Statistics Canada-supplied name",
        "statistics": {
          "2011": {
            "Population": {
              "value": 4123,
              "note": "This number is totally correct"
            }
          },
          ...more statistics...
        }
      }
    },
    ...more features...
  ],
  "utfgrids": [ /* Not banned by the GeoJSON spec */
    {
      "grid": ["...", "...", ... ], /* UTFGrid */
      "keys": [ "", "Province-11", "ElectoralDistrict-132", ... ] /* UTFGrid */
    }
  ]
}

The GeoJSON contains all data necessary. UTFGrid data is entirely redundant.

In mass-rendering tiles, we'll skip querying for statistics and instead show:
{ "statistics": { "0": { "TO-FILL": { "value": (region_id) } } } }. It's
complex because I was too lazy to make a simpler placeholder; nevertheless,
one can substitute proper values in with a regular expression.

We generate UTFGrid data by actually rendering the tiles onto in-memory SVGs
during creation. The benefit: the browser can quickly look up a GeoJSON
feature based on a pixel location.

Why is it a *list* of UTFGrids? Because there's no other way to transmit
partial hierarchies. For instance, if a Tract and Subdivision are in the
same spot, they're shown Tract-on-top-of-Subdivision on the map. But the
Subdivision isn't a parent of the Tract. The only way for the client to
see both (aside from actual hit-detection on vector data) is to transmit
two distinct hierarchies.

All this happens in ./render_mbtiles.py

==== Implementation

We keep a "work_queue" so that render_mbtiles.py can be run in multiple
processes and can be stopped and started without errors.

As it happens, Canada's north is *enormous* using Google's spherical
mercator projection, which stretches the poles. It also contains complex
polygons that take a long time to render. An average Nunavut tile takes
several times as long to render as an average New Brunswick one. Plus, the 
population is extremely low. We have limited time to render; these tiles
contain less useful information than the tiles in the Windsor corridor and
they take too long to render.

So we don't render the north past zoom level 12. This was done by running
./reject_northern_work_queue_tiles.py after the north was rendered at zoom
level 12 and before zoom level 13 began.

=== Phase 2: Statistics

We render a table of region_id -> statistics, which looks like the "statistics"
section in the GeoJSON tile description above. It's straightforward to generate
this: just loop over indicator_region_values, group by region and year, and
encode as JSON.

This is in ./render_statistics.py

=== Phase 3: Merge

1. Create a hash of region_id -> statistics, using the above table.
2. For each tile:
2a. Parse the tile's JSON
2b. For each "0" year in the JSON, replace the entire hash with statistics.
