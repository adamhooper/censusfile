== Tile format

Tiles are built using the GeoJSON specification.

They're built in two phases, though, because it takes a long time to generate GeoJSON data, even after optimization.

=== Phase 1: GeoJSON data, UTFGrid

See GeoJSON 1.0: http://geojson.org/geojson-spec.html
See UTFGrid 1.2 spec (as of 2012-01-11): https://github.com/mapbox/utfgrid-spec/blob/master/1.2/utfgrid.md

A tile looks like this:

{
  "type": "FeatureCollection", /* GeoJSON */
  "features": [ /* GeoJSON */
    {
      "type": "Feature",
      "geometry": ...GeoJSON geometry...
      "id": "DisseminationArea-12314",
      "properties": {
        "uid": "12314",
        "type": "DisseminationArea",
        "name": "Statistics Canada-supplied name",
        "statistics": {
          "2011": {
            "Population": {
              "value": 4123,
              "note": "This number is totally correct"
            }
          },
          ...more statistics...
        }
      }
    },
    ...more features...
  ],
  "utfgrids": [ /* Not banned by the GeoJSON spec */
    {
      "grid": ["...", "...", ... ], /* UTFGrid */
      "keys": [ "", "Province-11", "ElectoralDistrict-132", ... ] /* UTFGrid */
    }
  ]
}

The GeoJSON contains all data necessary. UTFGrid data is entirely redundant.

In mass-rendering tiles, we'll skip querying for statistics and instead show:
{ "statistics": { "0": { "TO-FILL": { "value": (region_id) } } } }. It's
complex because I was too lazy to make a simpler placeholder; nevertheless,
one can substitute proper values in with a regular expression.

We generate UTFGrid data by actually rendering the tiles onto in-memory SVGs
during creation. The benefit: the browser can quickly look up a GeoJSON
feature based on a pixel location.

Why is it a *list* of UTFGrids? Because there's no other way to transmit
partial hierarchies. For instance, if a Tract and Subdivision are in the
same spot, they're shown Tract-on-top-of-Subdivision on the map. But the
Subdivision isn't a parent of the Tract. The only way for the client to
see both (aside from actual hit-detection on vector data) is to transmit
two distinct hierarchies.

All this happens in ./render_mbtiles.py

==== Implementation

We start by creating a work_queue, which says which polygons should be
rendered at which zoom levels. It will contain a "worker" column
so multiple processes can coordinate who's working on what.

`CREATE TABLE work_queue (zoom_level INT NOT NULL,
    region_polygon_id INT NOT NULL, worker INT DEFAULT NULL,
    PRIMARY KEY (zoom_level, region_polygon_id));`
`INSERT INTO work_queue (zoom_level, region_polygon_id)
    SELECT id, generate_series(min_zoom_level, 15) FROM region_polygons;`
`CREATE INDEX work_queue_worker ON work_queue (worker);`

Then we run ./render_polygons_into_tiles.py, which does this:

1. Select a polygon and zoom level, and "lock" them in work_queue.
2. Simplify the polygon and slice it into all the tiles it fits in.
3. Add those tiles to region_polygon_tiles, which was created like this:

`CREATE TABLE region_polygon_tiles (region_polygon_id INT NOT NULL,
    zoom_level INT NOT NULL, tile_row INT NOT NULL, tile_column INT NOT NULL, 
    geojson_fragment TEXT NOT NULL,
    PRIMARY KEY (region_polygon_id, zoom_level, tile_row, tile_column));`

Finally, we run ./merge_region_polygon_tiles.py, which iterates over each
tile, merging GeoJSON fragments and adding region metadata.

=== Phase 2: Statistics

We render a table of region_id -> statistics, which looks like the "statistics"
section in the GeoJSON tile description above. It's straightforward to generate
this: just loop over indicator_region_values, group by region and year, and
encode as JSON.

This is in ./render_statistics.py

=== Phase 3: Merge

1. Create a hash of region_id -> statistics, using the above table.
2. For each tile:
2a. Parse the tile's JSON
2b. For each "0" year in the JSON, replace the entire hash with statistics.
